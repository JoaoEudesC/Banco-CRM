// 1 -  A diferença entre utilizar o mongodb atlas e o mongodbComapass comum  se deve ao fato de que a gente pode compartilhar o banco de dados para cada um poder usar da sua mnaquina , e o banco de dados nao ficar restringindo ao seu localhost , ser compartilhado
//2 -  Prestar atenção na utilização do dotenv que serve justamente para a segurança , para nao subir url com senha por exemplo para aplicação no push , como é o caso do mongodb atlas que a senha do banco é passado na url junto com o username
//3 - para utilizar o dotenv , temos que instalar ele através do npm (npm i dotenv) e em seguida vou configurar ele com o comando (require("dotenv").config()); no arquivo que inicializa , geralmente no index.js
//4 - em seguida criamos o arquivo .env e é la que vamos passar os arquivos que nao serão subidos para o projeto (const MONGODB_URI = process.env.MONGODB_URI;) => a utilização é feita assim , utilizando o nome da variável que vode definiu no .env
//5 - Na utilização da porta eu posso colocar tanto const port = 3000 direto , ou então posso passar exatamente como esta neste projeto atravês do .env
//6 - Eu consigo definir uma rota principal no meu app.js através do comando (app.use("/users" , router)) e apos isso todas as rotas que eu fizer a função no controller e passar no router , será passada depois do user , ou seja assim:http://localhost:3000/users/all ou http://localhost:3000/all
//7 - A maneira que eu utilizei no controller para criar uma rota para pegar todos os usuários do banco foi atraves de um comando do mongodb , chamado find para achar usuarios filtrados ou todos de uma so vez, através de um user schema importado que a criação da minha collection no banco de dados, colocando a mensagem (500) , que significa erro no servidor caso ocorra um erro e 200 , caso ocorra tudo certo
//8 - o Http quando eu estou usando o local host nunca tem o s , (https) => o servidor rodando na internet e não no localhost
//9 - Anotações sobre o post: como é uma função que se comunica diretamente com o banco de dados , quando a gente for fazer a função no controller , devemos criar ela com uma função assicrona
//10 - uma boa pratica é hashear com o bcrypt bem no inicio da criaçao do post , ou pode ser feito na criação do user schema tambem , é uma boa pratica fazer o post dessa maneira maneira enviando os codigos de validação , eu estou dizendo na criação do useSchema que ele vai pegar a requisição do usuário direto do body da requisição
//11 - boa prática para dar nome de rotas => não colocar verbo , colocar substantivo
//12 - na rota post nao é preciso colocar rota , é o unico que é passado so com ("/users") ele é passado neste caso na rota users na rota principal
//13 - Portanto há duas maneiras de se utilizar o bcrypt (Apliquei duas maneiras neste projeto)
//14 - Desenvolver o costume de no res.send, enviar mensagens bem completas com os codigos de requisição e tudo mais , data ,  e o atributo (message) para enviar uma mensagem, antes do atributo message tem que ser passado um atributo res.status.json , o metodo send é substituido pelo metodo json
//15 - o mongoose possui uma função interessante que se chama , findbyIdAndUpdate que facilita isso()
//16 - para fazer a busca para pegar um usuario em especifico por algum parametro deste usuario ou algo assim , como pegar para dar o upadate ( entre em headears e params e passe a key e o value , como se fosse no local storage) => se chama fazer uma busca por query params
//17 - assim como no login da nasa que foi feito , para passar a rota do update by id , passamos assim ("/:id") ou ("/usuario/:id")
//18 - O delete nos tambem temos a função findById e ele ja deleta tambem , de maneira simplificada , parecido com o di upadate que é o put e patch (a estrutura do delete e do upadate são muito parecidas , quase iguais na verdade so mudando o verbo http)
//19 - no delete nao temos o costume de enviar os dados do usuario deletado , somente um codigo , com uma mensagem escrita , codigo deletado com sucesso
//20 - no user Schema precisamos incluir e fazer a formtação do id , para que a gente possa utilizalo e mostralo e adicionar um novo quando for adicionar os usuarios
